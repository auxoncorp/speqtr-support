/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/v2/timelines/grouped_graph": {
    /**
     * Get the contents of the given timelines as a graph, grouped by event attrbutes. 
     * @description Get the contents of the given timelines as a graph, grouped by event attrbutes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by event.name.
     */
    get: operations["grouped_graph"];
  };
  "/v2/timelines/{timeline_id}": {
    /**
     * Get a single timeline 
     * @description Get a single timeline
     */
    get: operations["get_timeline"];
  };
  "/v2/workspaces": {
    /**
     * List all workspaces 
     * @description List all workspaces
     */
    get: operations["list_workspaces"];
  };
  "/v2/workspaces/{workspace_version_id}/grouped_graph": {
    /**
     * Get the contents of the workspace as a graph, grouped by event attrbutes. 
     * @description Get the contents of the workspace as a graph, grouped by event attrbutes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by (timeline.name, event.name).
     */
    get: operations["workspace_grouped_graph"];
  };
  "/v2/workspaces/{workspace_version_id}/segments": {
    /**
     * List all workspace segments 
     * @description List all workspace segments
     */
    get: operations["list_workspace_segments"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/grouped_graph": {
    /**
     * Get the contents of the segment as a graph, grouped by event attrbutes. 
     * @description Get the contents of the segment as a graph, grouped by event attrbutes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by (timeline.name, event.name).
     */
    get: operations["segment_grouped_graph"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/timelines": {
    /**
     * List all timelines in a specific segment 
     * @description List all timelines in a specific segment
     */
    get: operations["list_segment_timelines"];
  };
  "/v2/workspaces/{workspace_version_id}/timelines": {
    /**
     * List all workspace timelines 
     * @description List all workspace timelines
     */
    get: operations["list_workspace_timelines"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AttrVal: OneOf<[string, number, number, boolean, {
      TimelineId?: components["schemas"]["TimelineId"];
    }, {
      Timestamp?: components["schemas"]["Nanoseconds"];
    }, {
      LogicalTime?: components["schemas"]["LogicalTime"];
    }, {
      EventCoordinate?: components["schemas"]["EventCoordinate"];
    }, {
      BigInt?: string;
    }, {
      /** @enum {string} */
      NonFiniteFloat?: "NaN" | "-NaN" | "Infinity" | "-Infinity";
    }]>;
    EventCoordinate: {
      opaque_event_id?: (number)[];
      timeline_id?: components["schemas"]["TimelineId"];
    };
    /** @description A graph created by grouping together events by their attribute values. */
    GroupedGraph: {
      /** @description The grouping keys used to compute this graph */
      attr_keys: (string)[];
      /** @description The edges in the graph; node indices in this collection refer to `nodes`. */
      edges: (components["schemas"]["GroupedGraphEdge"])[];
      /** @description The nodes in the graph */
      nodes: (components["schemas"]["GroupedGraphNode"])[];
    };
    /** @description An edge in a `GroupedGraph` */
    GroupedGraphEdge: {
      /**
       * Format: int64 
       * @description How many times did this particular transition occur?
       */
      count: number;
      /** @description Corresponds to a position in the `GroupedGraph.nodes` array */
      destination: number;
      /** @description Corresponds to a position in the `GroupedGraph.nodes` array */
      source: number;
    };
    /** @description A node in a `GroupedGraph` */
    GroupedGraphNode: {
      /**
       * @description These are the values for this node corresponding to the `attr_keys`
       * of the parent `GroupedGraph`
       */
      attr_vals: (components["schemas"]["AttrVal"] | null)[];
      /**
       * Format: int64 
       * @description How many times did events of this group occur?
       */
      count?: number | null;
    };
    LogicalTime: (number)[];
    Nanoseconds: number;
    SegmentationRuleName: string;
    Timeline: {
      attributes: {
        [key: string]: components["schemas"]["AttrVal"] | undefined;
      };
      id: components["schemas"]["TimelineId"];
    };
    /** Format: uuid */
    TimelineId: string;
    TimelineOverview: {
      id: components["schemas"]["TimelineId"];
      name: string;
    };
    Workspace: {
      name: string;
      version_id: components["schemas"]["WorkspaceVersionId"];
    };
    /** @description A specific segment of a workspace. */
    WorkspaceSegmentId: {
      rule_name: components["schemas"]["SegmentationRuleName"];
      segment_name: components["schemas"]["WorkspaceSegmentName"];
      workspace_version_id: components["schemas"]["WorkspaceVersionId"];
    };
    /** @description A specific segment of a workspace. */
    WorkspaceSegmentMetadata: {
      id: components["schemas"]["WorkspaceSegmentId"];
      latest_receive_time?: components["schemas"]["Nanoseconds"] | null;
    };
    WorkspaceSegmentName: string;
    /** Format: uuid */
    WorkspaceVersionId: string;
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * Get the contents of the given timelines as a graph, grouped by event attrbutes. 
   * @description Get the contents of the given timelines as a graph, grouped by event attrbutes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by event.name.
   */
  grouped_graph: {
    parameters: {
      query: {
        /** @description Timeline Id */
        timeline_id: (string)[];
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Timeline Not Found */
      404: never;
    };
  };
  /**
   * Get a single timeline 
   * @description Get a single timeline
   */
  get_timeline: {
    parameters: {
      path: {
        /** @description Timeline id */
        timeline_id: string;
      };
    };
    responses: {
      /** @description Retrieve Timeline Successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Timeline"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Timeline Not Found */
      404: never;
    };
  };
  /**
   * List all workspaces 
   * @description List all workspaces
   */
  list_workspaces: {
    responses: {
      /** @description List all workspaces successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Workspace"])[];
        };
      };
      /** @description Operation not authorized */
      403: never;
    };
  };
  /**
   * Get the contents of the workspace as a graph, grouped by event attrbutes. 
   * @description Get the contents of the workspace as a graph, grouped by event attrbutes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by (timeline.name, event.name).
   */
  workspace_grouped_graph: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid workspace_version_id */
      400: never;
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: never;
    };
  };
  /**
   * List all workspace segments 
   * @description List all workspace segments
   */
  list_workspace_segments: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all segments successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["WorkspaceSegmentMetadata"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: never;
      /** @description Operation not authorized */
      403: never;
    };
  };
  /**
   * Get the contents of the segment as a graph, grouped by event attrbutes. 
   * @description Get the contents of the segment as a graph, grouped by event attrbutes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by (timeline.name, event.name).
   */
  segment_grouped_graph: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid workspace_version_id */
      400: never;
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: never;
    };
  };
  /**
   * List all timelines in a specific segment 
   * @description List all timelines in a specific segment
   */
  list_segment_timelines: {
    parameters: {
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List all timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineOverview"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: never;
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: never;
    };
  };
  /**
   * List all workspace timelines 
   * @description List all workspace timelines
   */
  list_workspace_timelines: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineOverview"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: never;
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: never;
    };
  };
}
