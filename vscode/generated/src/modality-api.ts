/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/v2/specs": {
    /**
     * List all specs 
     * @description List all specs
     */
    get: operations["list_specs"];
  };
  "/v2/specs/{spec_name}": {
    /**
     * Get the current version of the named spec 
     * @description Get the current version of the named spec
     */
    get: operations["get_spec"];
  };
  "/v2/specs/{spec_name}/versions": {
    /**
     * List all the versions of the named spec 
     * @description List all the versions of the named spec
     */
    get: operations["list_spec_versions"];
  };
  "/v2/specs/{spec_name}/versions/{spec_version}": {
    /**
     * Get a specific verison of the named spec 
     * @description Get a specific verison of the named spec
     */
    get: operations["get_spec_version"];
  };
  "/v2/specs/{spec_name}/versions/{spec_version}/results": {
    /**
     * List stored evaluation results for the given spec version 
     * @description List stored evaluation results for the given spec version
     */
    get: operations["list_spec_version_results"];
  };
  "/v2/timelines/grouped_graph": {
    /**
     * Get the contents of the given timelines as a graph, grouped by event attrbutes. 
     * @description Get the contents of the given timelines as a graph, grouped by event attrbutes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by event.name.
     */
    get: operations["grouped_graph"];
  };
  "/v2/timelines/{timeline_id}": {
    /**
     * Get a single timeline 
     * @description Get a single timeline
     */
    get: operations["get_timeline"];
  };
  "/v2/workspaces": {
    /**
     * List all workspaces 
     * @description List all workspaces
     */
    get: operations["list_workspaces"];
  };
  "/v2/workspaces/{workspace_version_id}/grouped_graph": {
    /**
     * Get the contents of the workspace as a graph, grouped by event attrbutes. 
     * @description Get the contents of the workspace as a graph, grouped by event attrbutes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by (timeline.name, event.name).
     */
    get: operations["workspace_grouped_graph"];
  };
  "/v2/workspaces/{workspace_version_id}/grouped_timelines": {
    /**
     * List workspace timelines, grouped by the givven attr keys 
     * @description List workspace timelines, grouped by the givven attr keys
     */
    get: operations["list_grouped_workspace_timelines"];
  };
  "/v2/workspaces/{workspace_version_id}/segments": {
    /**
     * List all workspace segments 
     * @description List all workspace segments
     */
    get: operations["list_workspace_segments"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/grouped_graph": {
    /**
     * Get the contents of the segment as a graph, grouped by event attributes. 
     * @description Get the contents of the segment as a graph, grouped by event attributes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by (timeline.name, event.name).
     */
    get: operations["segment_grouped_graph"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/grouped_timelines": {
    /**
     * List all timelines in a specific segment, grouped by the given attr keys 
     * @description List all timelines in a specific segment, grouped by the given attr keys
     */
    get: operations["list_grouped_segment_timelines"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/timeline_attr_keys": {
    /**
     * List all timeline attr keys in a specific segment 
     * @description List all timeline attr keys in a specific segment
     */
    get: operations["list_segment_timeline_attr_keys"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/timelines": {
    /**
     * List all timelines in a specific segment 
     * @description List all timelines in a specific segment
     */
    get: operations["list_segment_timelines"];
  };
  "/v2/workspaces/{workspace_version_id}/timeline_attr_keys": {
    /**
     * List the attr keys found on all timelines in this workspace 
     * @description List the attr keys found on all timelines in this workspace
     */
    get: operations["list_workspace_timeline_attr_keys"];
  };
  "/v2/workspaces/{workspace_version_id}/timelines": {
    /**
     * List all workspace timelines 
     * @description List all workspace timelines
     */
    get: operations["list_workspace_timelines"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AttrVal: OneOf<[string, number, number, boolean, {
      TimelineId?: components["schemas"]["TimelineId"];
    }, {
      Timestamp?: components["schemas"]["Nanoseconds"];
    }, {
      LogicalTime?: components["schemas"]["LogicalTime"];
    }, {
      EventCoordinate?: components["schemas"]["EventCoordinate"];
    }, {
      BigInt?: string;
    }, {
      /** @enum {string} */
      NonFiniteFloat?: "NaN" | "-NaN" | "Infinity" | "-Infinity";
    }]>;
    EventCoordinate: {
      opaque_event_id?: (number)[];
      timeline_id?: components["schemas"]["TimelineId"];
    };
    /** @description A graph created by grouping together events by their attribute values. */
    GroupedGraph: {
      /** @description The grouping keys used to compute this graph */
      attr_keys: (string)[];
      /** @description The edges in the graph; node indices in this collection refer to `nodes`. */
      edges: (components["schemas"]["GroupedGraphEdge"])[];
      /** @description The nodes in the graph */
      nodes: (components["schemas"]["GroupedGraphNode"])[];
    };
    /** @description An edge in a `GroupedGraph` */
    GroupedGraphEdge: {
      /**
       * Format: int64 
       * @description How many times did this particular transition occur?
       */
      count: number;
      /** @description Corresponds to a position in the `GroupedGraph.nodes` array */
      destination: number;
      /** @description Corresponds to a position in the `GroupedGraph.nodes` array */
      source: number;
    };
    /** @description A node in a `GroupedGraph` */
    GroupedGraphNode: {
      /**
       * @description These are the values for this node corresponding to the `attr_keys`
       * of the parent `GroupedGraph`
       */
      attr_vals: (components["schemas"]["AttrVal"] | null)[];
      /**
       * Format: int64 
       * @description How many times did events of this group occur?
       */
      count?: number | null;
    };
    LogicalTime: (number)[];
    /**
     * @description A serialization helper type, for when you actually want Option<AttrVal>. (We're
     * not allowed to implement ToSchema on that...)
     */
    MaybeAttrVal: OneOf<["None", {
      Some: components["schemas"]["AttrVal"];
    }]>;
    Nanoseconds: number;
    SegmentationRuleName: string;
    SpecContent: {
      metadata: components["schemas"]["SpecVersionMetadata"];
      speqtr: string;
    };
    SpecEvalOutcomeHighlights: {
      behaviors: (string)[];
      /** Format: int32 */
      regions_failing: number;
      /** Format: int32 */
      regions_passing: number;
      /** Format: int32 */
      regions_unknown: number;
      spec_eval_results_id: components["schemas"]["SpecEvalResultsId"];
      spec_name: string;
      spec_version_id: components["schemas"]["SpecVersionId"];
    };
    /** Format: uuid */
    SpecEvalResultsId: string;
    SpecName: string;
    /** Format: uuid */
    SpecVersionId: string;
    SpecVersionMetadata: {
      created_at: string;
      created_by: string;
      name: string;
      version: components["schemas"]["SpecVersionId"];
    };
    /** @description Spec operation errors */
    SpecsError: OneOf<[{
      SpecNotFound: components["schemas"]["SpecName"];
    }, {
      SpecVersionNotFound: components["schemas"]["SpecVersionId"];
    }, {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
    Timeline: {
      attributes: {
        [key: string]: components["schemas"]["AttrVal"] | undefined;
      };
      id: components["schemas"]["TimelineId"];
    };
    TimelineGroup: {
      group_attributes: {
        [key: string]: components["schemas"]["MaybeAttrVal"] | undefined;
      };
      timelines: (components["schemas"]["TimelineOverview"])[];
    };
    /** Format: uuid */
    TimelineId: string;
    TimelineOverview: {
      id: components["schemas"]["TimelineId"];
      name: string;
    };
    /** @description Timelines operation errors */
    TimelinesError: OneOf<[{
      /** @description Invalid Uuid */
      InvalidTimelineId: string;
    }, {
      TimelineNotFound: components["schemas"]["TimelineId"];
    }, {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
    Workspace: {
      name: string;
      version_id: components["schemas"]["WorkspaceVersionId"];
    };
    /** @description A specific segment of a workspace. */
    WorkspaceSegmentId: {
      rule_name: components["schemas"]["SegmentationRuleName"];
      segment_name: components["schemas"]["WorkspaceSegmentName"];
      workspace_version_id: components["schemas"]["WorkspaceVersionId"];
    };
    /** @description A specific segment of a workspace. */
    WorkspaceSegmentMetadata: {
      id: components["schemas"]["WorkspaceSegmentId"];
      latest_receive_time?: components["schemas"]["Nanoseconds"] | null;
    };
    WorkspaceSegmentName: string;
    /** Format: uuid */
    WorkspaceVersionId: string;
    /** @description Workspace operation errors */
    WorkspacesError: OneOf<[{
      /** @description Workspace not found */
      WorkspaceNotFound: string;
    }, "SegmentNotFound", "NoGroupsSpecified", {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * List all specs 
   * @description List all specs
   */
  list_specs: {
    responses: {
      /** @description List all specs successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["SpecVersionMetadata"])[];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * Get the current version of the named spec 
   * @description Get the current version of the named spec
   */
  get_spec: {
    responses: {
      /** @description Get spec successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SpecContent"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * List all the versions of the named spec 
   * @description List all the versions of the named spec
   */
  list_spec_versions: {
    responses: {
      /** @description List spec versions */
      200: {
        content: {
          "application/json": (components["schemas"]["SpecVersionMetadata"])[];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * Get a specific verison of the named spec 
   * @description Get a specific verison of the named spec
   */
  get_spec_version: {
    parameters: {
      path: {
        spec_name: components["schemas"]["SpecName"];
        spec_version: components["schemas"]["SpecVersionId"];
      };
    };
    responses: {
      /** @description List spec versions */
      200: {
        content: {
          "application/json": components["schemas"]["SpecContent"];
        };
      };
      /** @description Invalid spec version */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec or spec version not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * List stored evaluation results for the given spec version 
   * @description List stored evaluation results for the given spec version
   */
  list_spec_version_results: {
    parameters: {
      path: {
        spec_name: components["schemas"]["SpecName"];
        spec_version: components["schemas"]["SpecVersionId"];
      };
    };
    responses: {
      /** @description List spec evalutation results */
      200: {
        content: {
          "application/json": (components["schemas"]["SpecEvalOutcomeHighlights"])[];
        };
      };
      /** @description Invalid spec version */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec or spec version not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * Get the contents of the given timelines as a graph, grouped by event attrbutes. 
   * @description Get the contents of the given timelines as a graph, grouped by event attrbutes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by event.name.
   */
  grouped_graph: {
    parameters: {
      query: {
        /** @description Timeline Id */
        timeline_id: (string)[];
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid Timeline Id */
      400: {
        content: {
          "application/json": components["schemas"]["TimelinesError"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Timeline Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["TimelinesError"];
        };
      };
    };
  };
  /**
   * Get a single timeline 
   * @description Get a single timeline
   */
  get_timeline: {
    parameters: {
      path: {
        /** @description Timeline id */
        timeline_id: string;
      };
    };
    responses: {
      /** @description Retrieve Timeline Successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Timeline"];
        };
      };
      /** @description Invalid Timeline Id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Timeline Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["TimelinesError"];
        };
      };
    };
  };
  /**
   * List all workspaces 
   * @description List all workspaces
   */
  list_workspaces: {
    responses: {
      /** @description List all workspaces successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Workspace"])[];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * Get the contents of the workspace as a graph, grouped by event attrbutes. 
   * @description Get the contents of the workspace as a graph, grouped by event attrbutes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by (timeline.name, event.name).
   */
  workspace_grouped_graph: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List workspace timelines, grouped by the givven attr keys 
   * @description List workspace timelines, grouped by the givven attr keys
   */
  list_grouped_workspace_timelines: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List grouped timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineGroup"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all workspace segments 
   * @description List all workspace segments
   */
  list_workspace_segments: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all segments successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["WorkspaceSegmentMetadata"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * Get the contents of the segment as a graph, grouped by event attributes. 
   * @description Get the contents of the segment as a graph, grouped by event attributes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by (timeline.name, event.name).
   */
  segment_grouped_graph: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all timelines in a specific segment, grouped by the given attr keys 
   * @description List all timelines in a specific segment, grouped by the given attr keys
   */
  list_grouped_segment_timelines: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List grouped timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineGroup"])[];
        };
      };
      /** @description No grouping attrs specified */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all timeline attr keys in a specific segment 
   * @description List all timeline attr keys in a specific segment
   */
  list_segment_timeline_attr_keys: {
    parameters: {
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List all timelineattr_keys successfully */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all timelines in a specific segment 
   * @description List all timelines in a specific segment
   */
  list_segment_timelines: {
    parameters: {
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List all timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineOverview"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List the attr keys found on all timelines in this workspace 
   * @description List the attr keys found on all timelines in this workspace
   */
  list_workspace_timeline_attr_keys: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all timeline attr keys successfully */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all workspace timelines 
   * @description List all workspace timelines
   */
  list_workspace_timelines: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineOverview"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
}
