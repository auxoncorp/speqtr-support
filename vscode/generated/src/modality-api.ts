/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
type OneOf<T extends any[]> = T extends [infer Only] ? Only : T extends [infer A, infer B, ...infer Rest] ? OneOf<[XOR<A, B>, ...Rest]> : never;

export interface paths {
  "/v2/events/{timeline_id}/summary": {
    /**
     * Get an event summary for a single timeline 
     * @description Get an event summary for a single timeline
     */
    get: operations["get_events_summary_for_timeline"];
  };
  "/v2/mutations": {
    /**
     * List all mutations 
     * @description List all mutations
     */
    get: operations["list_mutations"];
  };
  "/v2/mutations/{workspace_version_id}/segments/{rule_name}/{segment_name}": {
    /**
     * List all mutations for the given segment 
     * @description List all mutations for the given segment
     */
    get: operations["list_segment_mutations"];
  };
  "/v2/mutators": {
    /**
     * List mutators 
     * @description List mutators
     */
    get: operations["list_mutators"];
  };
  "/v2/specs": {
    /**
     * List all specs 
     * @description List all specs
     */
    get: operations["list_specs"];
  };
  "/v2/specs/{spec_name}": {
    /**
     * Get the current version of the named spec 
     * @description Get the current version of the named spec
     */
    get: operations["get_spec"];
  };
  "/v2/specs/{spec_name}/structure": {
    /**
     * Get the structure of behaviors and cases for the stored spec 
     * @description Get the structure of behaviors and cases for the stored spec
     */
    get: operations["get_spec_structure"];
  };
  "/v2/specs/{spec_name}/versions": {
    /**
     * List all the versions of the named spec 
     * @description List all the versions of the named spec
     */
    get: operations["list_spec_versions"];
  };
  "/v2/specs/{spec_name}/versions/{spec_version}": {
    /**
     * Get a specific verison of the named spec 
     * @description Get a specific verison of the named spec
     */
    get: operations["get_spec_version"];
  };
  "/v2/specs/{spec_name}/versions/{spec_version}/results": {
    /**
     * List stored evaluation results for the given spec version 
     * @description List stored evaluation results for the given spec version
     */
    get: operations["list_spec_version_results"];
  };
  "/v2/specs/{spec_name}/versions/{spec_version}/structure": {
    /**
     * List stored evaluation results for the given spec version 
     * @description List stored evaluation results for the given spec version
     */
    get: operations["get_spec_version_structure"];
  };
  "/v2/timelines/grouped_graph": {
    /**
     * Get the contents of the given timelines as a graph, grouped by event attrbutes. 
     * @description Get the contents of the given timelines as a graph, grouped by event attrbutes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by event.name.
     */
    get: operations["grouped_graph"];
  };
  "/v2/timelines/{timeline_id}": {
    /**
     * Get a single timeline 
     * @description Get a single timeline
     */
    get: operations["get_timeline"];
  };
  "/v2/workspaces": {
    /**
     * List all workspaces 
     * @description List all workspaces
     */
    get: operations["list_workspaces"];
  };
  "/v2/workspaces/{workspace_version_id}/grouped_graph": {
    /**
     * Get the contents of the workspace as a graph, grouped by event attrbutes. 
     * @description Get the contents of the workspace as a graph, grouped by event attrbutes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by (timeline.name, event.name).
     */
    get: operations["workspace_grouped_graph"];
  };
  "/v2/workspaces/{workspace_version_id}/grouped_timelines": {
    /**
     * List workspace timelines, grouped by the givven attr keys 
     * @description List workspace timelines, grouped by the givven attr keys
     */
    get: operations["list_grouped_workspace_timelines"];
  };
  "/v2/workspaces/{workspace_version_id}/segments": {
    /**
     * List all workspace segments 
     * @description List all workspace segments
     */
    get: operations["list_workspace_segments"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/grouped_graph": {
    /**
     * Get the contents of the segment as a graph, grouped by event attributes. 
     * @description Get the contents of the segment as a graph, grouped by event attributes.
     * 
     * If no keys are specified using the 'group_by' query parameter,
     * the graph is grouped by (timeline.name, event.name).
     */
    get: operations["segment_grouped_graph"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/grouped_timelines": {
    /**
     * List all timelines in a specific segment, grouped by the given attr keys 
     * @description List all timelines in a specific segment, grouped by the given attr keys
     */
    get: operations["list_grouped_segment_timelines"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/spec_coverage": {
    /**
     * Get the spec-coverage of the segment. 
     * @description Get the spec-coverage of the segment.
     * 
     * If no filters are 'group_by' query parameter,
     * the graph is grouped by (timeline.name, event.name).
     */
    get: operations["segment_spec_coverage"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/spec_summary": {
    /**
     * List the named spec evaluation summaries of the segment 
     * @description List the named spec evaluation summaries of the segment
     */
    get: operations["segment_spec_summary"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/timeline_attr_keys": {
    /**
     * List all timeline attr keys in a specific segment 
     * @description List all timeline attr keys in a specific segment
     */
    get: operations["list_segment_timeline_attr_keys"];
  };
  "/v2/workspaces/{workspace_version_id}/segments/{rule_name}/{segment_name}/timelines": {
    /**
     * List all timelines in a specific segment 
     * @description List all timelines in a specific segment
     */
    get: operations["list_segment_timelines"];
  };
  "/v2/workspaces/{workspace_version_id}/timeline_attr_keys": {
    /**
     * List the attr keys found on all timelines in this workspace 
     * @description List the attr keys found on all timelines in this workspace
     */
    get: operations["list_workspace_timeline_attr_keys"];
  };
  "/v2/workspaces/{workspace_version_id}/timelines": {
    /**
     * List all workspace timelines 
     * @description List all workspace timelines
     */
    get: operations["list_workspace_timelines"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AttrVal: OneOf<[string, number, number, boolean, {
      TimelineId?: components["schemas"]["TimelineId"];
    }, {
      Timestamp?: components["schemas"]["Nanoseconds"];
    }, {
      LogicalTime?: components["schemas"]["LogicalTime"];
    }, {
      EventCoordinate?: components["schemas"]["EventCoordinate"];
    }, {
      BigInt?: string;
    }, {
      /** @enum {string} */
      NonFiniteFloat?: "NaN" | "-NaN" | "Infinity" | "-Infinity";
    }]>;
    AttributeMap: {
      [key: string]: components["schemas"]["AttrVal"] | undefined;
    };
    /** @enum {string} */
    BehaviorCaseType: "Nominal" | "Recovery" | "Prohibited";
    BehaviorCoverage: {
      case_coverage: {
        [key: string]: components["schemas"]["CaseCoverage"] | undefined;
      };
      ever_vacuous: boolean;
      name: string;
      test_counts: components["schemas"]["TestCounts"];
      triggered_n_times?: number | null;
      vacuous_n_times: number;
    };
    BehaviorName: string;
    BehaviorStructure: {
      attributes?: components["schemas"]["AttributeMap"];
      cases?: ((components["schemas"]["CaseName"] & components["schemas"]["BehaviorCaseType"] & components["schemas"]["AttributeMap"])[])[];
      until?: ((components["schemas"]["CaseName"] & components["schemas"]["AttributeMap"])[]) | null;
      when?: ((components["schemas"]["CaseName"] & components["schemas"]["AttributeMap"])[]) | null;
    };
    CaseCoverage: {
      case_type: components["schemas"]["BehaviorCaseType"];
      ever_matched: boolean;
      matched_n_times: number;
      name: string;
    };
    CaseName: string;
    CoverageAggregates: {
      n_behaviors: number;
      n_behaviors_executed: number;
      n_behaviors_failing: number;
      n_behaviors_passing: number;
      n_behaviors_vacuous: number;
      n_cases: number;
      n_cases_ever_matched: number;
      n_specs: number;
      n_specs_executed: number;
      n_specs_failing: number;
      n_specs_passing: number;
      /** Format: double */
      percentage_behaviors_executed: number;
      /** Format: double */
      percentage_behaviors_failing: number;
      /** Format: double */
      percentage_behaviors_passing: number;
      /** Format: double */
      percentage_behaviors_vacuous: number;
      /** Format: double */
      percentage_cases_ever_matched: number;
      /** Format: double */
      percentage_specs_executed: number;
      /** Format: double */
      percentage_specs_failing: number;
      /** Format: double */
      percentage_specs_passing: number;
    };
    EventCoordinate: {
      opaque_event_id?: (number)[];
      timeline_id?: components["schemas"]["TimelineId"];
    };
    EventSummary: {
      attributes: (string)[];
      /** Format: int32 */
      n_instances: number;
      name?: string | null;
    };
    /** @description Events operation errors */
    EventsError: OneOf<[{
      /** @description Invalid Uuid */
      InvalidTimelineId: string;
    }, {
      TimelineNotFound: components["schemas"]["TimelineId"];
    }, {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
    EventsSummary: {
      events: (components["schemas"]["EventSummary"])[];
    };
    /** @description A graph created by grouping together events by their attribute values. */
    GroupedGraph: {
      /** @description The grouping keys used to compute this graph */
      attr_keys: (string)[];
      /** @description The edges in the graph; node indices in this collection refer to `nodes`. */
      edges: (components["schemas"]["GroupedGraphEdge"])[];
      /** @description The nodes in the graph */
      nodes: (components["schemas"]["GroupedGraphNode"])[];
    };
    /** @description An edge in a `GroupedGraph` */
    GroupedGraphEdge: {
      /**
       * Format: int64 
       * @description How many times did this particular transition occur?
       */
      count: number;
      /** @description Corresponds to a position in the `GroupedGraph.nodes` array */
      destination: number;
      /** @description Corresponds to a position in the `GroupedGraph.nodes` array */
      source: number;
    };
    /** @description A node in a `GroupedGraph` */
    GroupedGraphNode: {
      /**
       * @description These are the values for this node corresponding to the `attr_keys`
       * of the parent `GroupedGraph`
       */
      attr_vals: (components["schemas"]["AttrVal"] | null)[];
      /**
       * Format: int64 
       * @description How many times did events of this group occur?
       */
      count?: number | null;
    };
    LogicalTime: (number)[];
    /**
     * @description A serialization helper type, for when you actually want Option<AttrVal>. (We're
     * not allowed to implement ToSchema on that...)
     */
    MaybeAttrVal: OneOf<["None", {
      Some: components["schemas"]["AttrVal"];
    }]>;
    Mutation: {
      /** Format: int64 */
      created_at_utc_seconds: number;
      linked_experiment?: string | null;
      mutation_id: components["schemas"]["MutationId"];
      mutator_attributes: {
        [key: string]: components["schemas"]["AttrVal"] | undefined;
      };
      mutator_id: components["schemas"]["MutatorId"];
      params: {
        [key: string]: components["schemas"]["AttrVal"] | undefined;
      };
      region_details_summary?: components["schemas"]["MutationRegionDetailsSummary"] | null;
    };
    /** Format: uuid */
    MutationId: string;
    MutationRegionDetails: {
      /**
       * @description Maps to the "modality.mutation.clear_communicated" event name,
       * and the `modality.mutation.success` attribute on such an event
       */
      clear_communicated_and_success?: ((components["schemas"]["EventCoordinate"] & (boolean | null))[]) | null;
      /**
       * @description Maps to the "modality.mutation.command_communicated" event name,
       * and the `modality.mutation.success` attribute on such an event
       */
      command_communicated_and_success?: ((components["schemas"]["EventCoordinate"] & (boolean | null))[]) | null;
      /**
       * @description Maps to the "modality.mutation.injected" event name,
       * and the `modality.mutation.success` attribute on such an event
       */
      inject_attempted_and_success?: ((components["schemas"]["EventCoordinate"] & (boolean | null))[]) | null;
    };
    MutationRegionDetailsSummary: {
      overall: components["schemas"]["MutationRegionDetails"];
      regions: ((components["schemas"]["RegionKind"] & components["schemas"]["MutationRegionDetails"])[])[];
    };
    /** @description Mutations operation errors */
    MutationsError: OneOf<["InvalidMutatorId", {
      /** @description Workspace not found */
      WorkspaceNotFound: string;
    }, "SegmentNotFound", {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
    Mutator: {
      mutator_attributes: {
        [key: string]: components["schemas"]["AttrVal"] | undefined;
      };
      mutator_id: components["schemas"]["MutatorId"];
      mutator_state: components["schemas"]["MutatorState"];
    };
    /** Format: uuid */
    MutatorId: string;
    /** @enum {string} */
    MutatorState: "Available" | "Retired" | "TimedOut" | "Disconnected";
    /** @description Mutator operation errors */
    MutatorsError: OneOf<[{
      /** @description Invalid mutator filter expression */
      InvalidMutatorFilter: string;
    }, {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
    Nanoseconds: number;
    RegionKind: OneOf<[{
      WholeWorkspace: components["schemas"]["WholeWorkspaceRegionKind"];
    }, {
      Segment: components["schemas"]["SegmentRegionKind"];
    }]>;
    SegmentCoverage: {
      coverage_aggregates: components["schemas"]["CoverageAggregates"];
      spec_coverages: (components["schemas"]["SpecCoverage"])[];
    };
    SegmentRegionKind: {
      id: components["schemas"]["WorkspaceSegmentId"];
      timeline_filter?: components["schemas"]["UnstructuredTimelineFilter"] | null;
      workspace_name: components["schemas"]["WorkspaceName"];
    };
    SegmentationRuleName: string;
    SpecContent: {
      metadata: components["schemas"]["SpecVersionMetadata"];
      speqtr: string;
    };
    SpecCoverage: {
      behavior_to_coverage: {
        [key: string]: components["schemas"]["BehaviorCoverage"] | undefined;
      };
      spec_at_version_meta: components["schemas"]["SpecVersionMetadata"];
      test_counts: components["schemas"]["TestCounts"];
    };
    SpecEvalOutcomeHighlights: {
      behaviors: (string)[];
      /** Format: int32 */
      regions_failing: number;
      /** Format: int32 */
      regions_passing: number;
      /** Format: int32 */
      regions_unknown: number;
      /** Format: int32 */
      regions_vacuous: number;
      /** Format: int64 */
      spec_eval_at_utc_seconds: number;
      spec_eval_results_id: components["schemas"]["SpecEvalResultsId"];
      spec_name: string;
      spec_version_id: components["schemas"]["SpecVersionId"];
    };
    /** Format: uuid */
    SpecEvalResultsId: string;
    SpecName: string;
    SpecSegmentEvalOutcomeSummary: {
      /** Format: int32 */
      regions_failing: number;
      /** Format: int32 */
      regions_passing: number;
      /** Format: int32 */
      regions_unknown: number;
      /** Format: int32 */
      regions_vacuous: number;
      spec_name: string;
    };
    SpecStructure: {
      attributes?: components["schemas"]["AttributeMap"];
      behaviors?: ((components["schemas"]["BehaviorName"] & components["schemas"]["BehaviorStructure"])[])[];
    };
    /** Format: uuid */
    SpecVersionId: string;
    SpecVersionMetadata: {
      created_at: string;
      created_by: string;
      name: string;
      version: components["schemas"]["SpecVersionId"];
      /** @description Not uniquely identifying, but helps give a sense of ordering */
      version_number: number;
    };
    /** @description Spec operation errors */
    SpecsError: OneOf<[{
      SpecNotFound: components["schemas"]["SpecName"];
    }, {
      SpecVersionNotFound: components["schemas"]["SpecVersionId"];
    }, {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
    TestCounts: {
      ever_executed: boolean;
      ever_failed: boolean;
      ever_passed: boolean;
      executed_n_times: number;
      failed_n_times: number;
      passed_n_times: number;
    };
    Timeline: {
      attributes: {
        [key: string]: components["schemas"]["AttrVal"] | undefined;
      };
      id: components["schemas"]["TimelineId"];
    };
    TimelineGroup: {
      group_attributes: {
        [key: string]: components["schemas"]["MaybeAttrVal"] | undefined;
      };
      timelines: (components["schemas"]["TimelineOverview"])[];
    };
    /** Format: uuid */
    TimelineId: string;
    TimelineOverview: {
      id: components["schemas"]["TimelineId"];
      name?: string | null;
    };
    /** @description Timelines operation errors */
    TimelinesError: OneOf<[{
      /** @description Invalid Uuid */
      InvalidTimelineId: string;
    }, {
      TimelineNotFound: components["schemas"]["TimelineId"];
    }, {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
    /**
     * @description Stringy representation of an unparsed, unstructured DSL for expressing how to filter timelines,
     * likely through attribute evaluation.
     */
    UnstructuredTimelineFilter: string;
    WholeWorkspaceRegionKind: {
      timeline_filter?: components["schemas"]["UnstructuredTimelineFilter"] | null;
      workspace_name: components["schemas"]["WorkspaceName"];
      workspace_version_id: components["schemas"]["WorkspaceVersionId"];
    };
    Workspace: {
      name: string;
      version_id: components["schemas"]["WorkspaceVersionId"];
    };
    WorkspaceName: string;
    /** @description A specific segment of a workspace. */
    WorkspaceSegmentId: {
      rule_name: components["schemas"]["SegmentationRuleName"];
      segment_name: components["schemas"]["WorkspaceSegmentName"];
      workspace_version_id: components["schemas"]["WorkspaceVersionId"];
    };
    /** @description A specific segment of a workspace. */
    WorkspaceSegmentMetadata: {
      id: components["schemas"]["WorkspaceSegmentId"];
      latest_receive_time?: components["schemas"]["Nanoseconds"] | null;
    };
    WorkspaceSegmentName: string;
    /** Format: uuid */
    WorkspaceVersionId: string;
    /** @description Workspace operation errors */
    WorkspacesError: OneOf<[{
      /** @description Workspace not found */
      WorkspaceNotFound: string;
    }, "SegmentNotFound", "NoGroupsSpecified", "InvalidSpecVersionId", "InvalidSpecResultId", {
      /** @description Internal Server Error */
      Internal: string;
    }]>;
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  /**
   * Get an event summary for a single timeline 
   * @description Get an event summary for a single timeline
   */
  get_events_summary_for_timeline: {
    parameters: {
      path: {
        /** @description Timeline id */
        timeline_id: string;
      };
    };
    responses: {
      /** @description Retrieved Events Summary Successfully */
      200: {
        content: {
          "application/json": components["schemas"]["EventsSummary"];
        };
      };
      /** @description Invalid Timeline Id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Timeline Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["EventsError"];
        };
      };
    };
  };
  /**
   * List all mutations 
   * @description List all mutations
   */
  list_mutations: {
    parameters: {
      query: {
        /** @description Mutator ID */
        mutator_id?: string | null;
        /** @description Experiment name */
        experiment?: string | null;
      };
    };
    responses: {
      /** @description List mutations successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Mutation"])[];
        };
      };
      /** @description Invalid mutator_id */
      400: {
        content: {
          "application/json": components["schemas"]["MutationsError"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["MutationsError"];
        };
      };
    };
  };
  /**
   * List all mutations for the given segment 
   * @description List all mutations for the given segment
   */
  list_segment_mutations: {
    parameters: {
      query: {
        /** @description Mutator ID */
        mutator_id?: string | null;
        /** @description Experiment name */
        experiment?: string | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List mutations successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Mutation"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "application/json": components["schemas"]["MutationsError"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["MutationsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["MutationsError"];
        };
      };
    };
  };
  /**
   * List mutators 
   * @description List mutators
   */
  list_mutators: {
    parameters: {
      query: {
        /** @description Mutator filter expression */
        mutator_filter?: string | null;
      };
    };
    responses: {
      /** @description List mutators successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Mutator"])[];
        };
      };
      /** @description Invalid mutator_filter */
      400: {
        content: {
          "application/json": components["schemas"]["MutatorsError"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["MutatorsError"];
        };
      };
    };
  };
  /**
   * List all specs 
   * @description List all specs
   */
  list_specs: {
    responses: {
      /** @description List all specs successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["SpecVersionMetadata"])[];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * Get the current version of the named spec 
   * @description Get the current version of the named spec
   */
  get_spec: {
    responses: {
      /** @description Get spec successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SpecContent"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * Get the structure of behaviors and cases for the stored spec 
   * @description Get the structure of behaviors and cases for the stored spec
   */
  get_spec_structure: {
    responses: {
      /** @description Get spec structure successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SpecStructure"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * List all the versions of the named spec 
   * @description List all the versions of the named spec
   */
  list_spec_versions: {
    responses: {
      /** @description List spec versions */
      200: {
        content: {
          "application/json": (components["schemas"]["SpecVersionMetadata"])[];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * Get a specific verison of the named spec 
   * @description Get a specific verison of the named spec
   */
  get_spec_version: {
    parameters: {
      path: {
        spec_name: components["schemas"]["SpecName"];
        spec_version: components["schemas"]["SpecVersionId"];
      };
    };
    responses: {
      /** @description List spec versions */
      200: {
        content: {
          "application/json": components["schemas"]["SpecContent"];
        };
      };
      /** @description Invalid spec version */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec or spec version not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * List stored evaluation results for the given spec version 
   * @description List stored evaluation results for the given spec version
   */
  list_spec_version_results: {
    parameters: {
      path: {
        spec_name: components["schemas"]["SpecName"];
        spec_version: components["schemas"]["SpecVersionId"];
      };
    };
    responses: {
      /** @description List spec evalutation results */
      200: {
        content: {
          "application/json": (components["schemas"]["SpecEvalOutcomeHighlights"])[];
        };
      };
      /** @description Invalid spec version */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec or spec version not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * List stored evaluation results for the given spec version 
   * @description List stored evaluation results for the given spec version
   */
  get_spec_version_structure: {
    parameters: {
      path: {
        spec_name: components["schemas"]["SpecName"];
        spec_version: components["schemas"]["SpecVersionId"];
      };
    };
    responses: {
      /** @description Get spec version structure */
      200: {
        content: {
          "application/json": components["schemas"]["SpecStructure"];
        };
      };
      /** @description Invalid spec version */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Spec or spec version not found */
      404: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["SpecsError"];
        };
      };
    };
  };
  /**
   * Get the contents of the given timelines as a graph, grouped by event attrbutes. 
   * @description Get the contents of the given timelines as a graph, grouped by event attrbutes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by event.name.
   */
  grouped_graph: {
    parameters: {
      query: {
        /** @description Timeline Id */
        timeline_id: (string)[];
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid Timeline Id */
      400: {
        content: {
          "application/json": components["schemas"]["TimelinesError"];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Timeline Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["TimelinesError"];
        };
      };
    };
  };
  /**
   * Get a single timeline 
   * @description Get a single timeline
   */
  get_timeline: {
    parameters: {
      path: {
        /** @description Timeline id */
        timeline_id: string;
      };
    };
    responses: {
      /** @description Retrieve Timeline Successfully */
      200: {
        content: {
          "application/json": components["schemas"]["Timeline"];
        };
      };
      /** @description Invalid Timeline Id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Timeline Not Found */
      404: {
        content: {
          "application/json": components["schemas"]["TimelinesError"];
        };
      };
    };
  };
  /**
   * List all workspaces 
   * @description List all workspaces
   */
  list_workspaces: {
    responses: {
      /** @description List all workspaces successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["Workspace"])[];
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * Get the contents of the workspace as a graph, grouped by event attrbutes. 
   * @description Get the contents of the workspace as a graph, grouped by event attrbutes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by (timeline.name, event.name).
   */
  workspace_grouped_graph: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List workspace timelines, grouped by the givven attr keys 
   * @description List workspace timelines, grouped by the givven attr keys
   */
  list_grouped_workspace_timelines: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List grouped timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineGroup"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all workspace segments 
   * @description List all workspace segments
   */
  list_workspace_segments: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all segments successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["WorkspaceSegmentMetadata"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * Get the contents of the segment as a graph, grouped by event attributes. 
   * @description Get the contents of the segment as a graph, grouped by event attributes.
   * 
   * If no keys are specified using the 'group_by' query parameter,
   * the graph is grouped by (timeline.name, event.name).
   */
  segment_grouped_graph: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description Retrieve the graph successfully */
      200: {
        content: {
          "application/json": components["schemas"]["GroupedGraph"];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all timelines in a specific segment, grouped by the given attr keys 
   * @description List all timelines in a specific segment, grouped by the given attr keys
   */
  list_grouped_segment_timelines: {
    parameters: {
      query: {
        /** @description Grouping attr key */
        group_by?: (string)[] | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List grouped timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineGroup"])[];
        };
      };
      /** @description No grouping attrs specified */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * Get the spec-coverage of the segment. 
   * @description Get the spec-coverage of the segment.
   * 
   * If no filters are 'group_by' query parameter,
   * the graph is grouped by (timeline.name, event.name).
   */
  segment_spec_coverage: {
    parameters: {
      query: {
        /** @description Include the latest results of the latest version of this spec in the analysis */
        spec_name?: (string)[] | null;
        /** @description Include the latest results of this spec version in the analysis */
        spec_version?: (string)[] | null;
        /** @description Include this spec result in the analysis */
        spec_result?: (string)[] | null;
        /** @description Expression for filtering specs from the perspective of spec attributes. */
        spec_filter?: string | null;
        /** @description Expression for filtering specs and their behaviors from the perspective of behavior attributes. */
        behavior_filter?: string | null;
        /** @description Expression for filtering specs and their behaviors from the perspective of case attributes. */
        case_filter?: string | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description Retrieve the segment spec coverage successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SegmentCoverage"];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List the named spec evaluation summaries of the segment 
   * @description List the named spec evaluation summaries of the segment
   */
  segment_spec_summary: {
    parameters: {
      query: {
        /** @description Expression for filtering specs from the perspective of spec attributes. */
        spec_filter?: string | null;
        /** @description Expression for filtering specs and their behaviors from the perspective of behavior attributes. */
        behavior_filter?: string | null;
        /** @description Expression for filtering specs and their behaviors from the perspective of case attributes. */
        case_filter?: string | null;
      };
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description Retrieve the segment spec summary successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["SpecSegmentEvalOutcomeSummary"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all timeline attr keys in a specific segment 
   * @description List all timeline attr keys in a specific segment
   */
  list_segment_timeline_attr_keys: {
    parameters: {
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List all timelineattr_keys successfully */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all timelines in a specific segment 
   * @description List all timelines in a specific segment
   */
  list_segment_timelines: {
    parameters: {
      path: {
        /** @description Workspace Version Id */
        workspace_version_id: components["schemas"]["WorkspaceVersionId"];
        /** @description Segmentation Rule Name */
        rule_name: components["schemas"]["SegmentationRuleName"];
        /** @description Segment Name */
        segment_name: components["schemas"]["WorkspaceSegmentName"];
      };
    };
    responses: {
      /** @description List all timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineOverview"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace or segment not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List the attr keys found on all timelines in this workspace 
   * @description List the attr keys found on all timelines in this workspace
   */
  list_workspace_timeline_attr_keys: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all timeline attr keys successfully */
      200: {
        content: {
          "application/json": (string)[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
  /**
   * List all workspace timelines 
   * @description List all workspace timelines
   */
  list_workspace_timelines: {
    parameters: {
      path: {
        /** @description Workspace version id */
        workspace_version_id: string;
      };
    };
    responses: {
      /** @description List all timelines successfully */
      200: {
        content: {
          "application/json": (components["schemas"]["TimelineOverview"])[];
        };
      };
      /** @description Invalid workspace_version_id */
      400: {
        content: {
          "text/plain": string;
        };
      };
      /** @description Operation not authorized */
      403: never;
      /** @description Workspace not found */
      404: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
      /** @description Internal Server Error */
      500: {
        content: {
          "application/json": components["schemas"]["WorkspacesError"];
        };
      };
    };
  };
}
